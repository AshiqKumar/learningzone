 Basic-Level Questions
 ----------------------
üß† What is the Singleton Design Pattern?
Ans: **Singleton** is a creational design pattern that ensures a class has only **one instance** and provides a global point of access to that instance.

**Key Concept:** "One class, one instance, global access"

**Structure:**
- Private constructor (prevents direct instantiation)
- Static method to get the instance (global access point)
- Static variable to store the single instance
- Deleted copy constructor and assignment operator (prevents copying)

üß† Why would you use a Singleton?
Ans: **Use Singleton when you need exactly one instance of a class throughout your application:**

**Common Use Cases:**
‚úÖ **Logger** - Single point for all application logging
‚úÖ **Configuration Manager** - One source of truth for app settings
‚úÖ **Database Connection Pool** - Manage shared database connections
‚úÖ **Cache Manager** - Single cache instance shared across the app
‚úÖ **Print Spooler** - Only one instance should manage print jobs
‚úÖ **Device Drivers** - Hardware should have single point of access
‚úÖ **File System** - Single instance to manage file operations
‚úÖ **Application Settings** - Global application state

**Benefits:**
- Controlled access to sole instance
- Reduced memory footprint (only one instance)
- Global access point
- Lazy initialization possible (create when needed)

üß† How do you implement a Singleton in C++?
Ans: **C++ Implementation (Modern C++11+):**
```cpp
class Singleton {
private:
    int data;
    Singleton() : data(0) {}                           // Private constructor
    Singleton(const Singleton&) = delete;             // Delete copy constructor
    Singleton& operator=(const Singleton&) = delete;  // Delete assignment

public:
    static Singleton& getInstance() {
        static Singleton instance;  // Thread-safe since C++11
        return instance;
    }
    
    void setData(int val) { data = val; }
    int getData() const { return data; }
};

// Usage:
Singleton& s = Singleton::getInstance();
```

üß† What are the key characteristics of a Singleton?
Ans: **Essential characteristics that define a Singleton:**

**1. Single Instance**
- Only one instance can exist throughout the application lifetime
- All requests return the same instance

**2. Global Access Point**
- Static method (usually `getInstance()`) provides global access
- Can be accessed from anywhere in the code

**3. Controlled Instantiation**
- Private constructor prevents direct object creation
- Class controls when and how the instance is created

**4. Copy Prevention**
- Copy constructor and assignment operator are deleted/private
- Prevents creating additional instances through copying

**5. Thread Safety (Modern implementations)**
- Safe to use in multi-threaded environments
- Ensures only one instance even with concurrent access

**6. Lazy or Eager Initialization**
- Can be created on first use (lazy) or at program start (eager)
- Depends on implementation choice

**Code Example showing all characteristics:**
```cpp
class Singleton {
private:
    static Singleton* instance;                        // 1. Single instance storage
    Singleton() {}                                     // 3. Private constructor
    Singleton(const Singleton&) = delete;             // 4. Prevent copying
    Singleton& operator=(const Singleton&) = delete;  // 4. Prevent assignment

public:
    static Singleton* getInstance() {                  // 2. Global access point
        if (instance == nullptr) {                     // 6. Lazy initialization
            instance = new Singleton();
        }
        return instance;
    }
};
```

üß† How do you prevent multiple instances of a Singleton class?
Ans: **Multiple techniques to enforce single instance:**

**1. Private Constructor**
```cpp
class Singleton {
private:
    Singleton() {}  // Prevents: Singleton obj;
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

**2. Delete Copy Constructor and Assignment Operator**
```cpp
class Singleton {
private:
    Singleton() {}
public:
    // Prevent copying
    Singleton(const Singleton&) = delete;              // Prevents: Singleton s2(s1);
    Singleton& operator=(const Singleton&) = delete;   // Prevents: s2 = s1;
    
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

**3. Static Instance Management**
```cpp
class Singleton {
private:
    static Singleton* instance;
    static bool instanceExists;
    
    Singleton() {
        if (instanceExists) {
            throw std::runtime_error("Instance already exists!");
        }
        instanceExists = true;
    }
    
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
};
```

**4. Thread-Safe Implementation (C++11)**
```cpp
class Singleton {
private:
    Singleton() {}
public:
    static Singleton& getInstance() {
        static Singleton instance;  // Guaranteed thread-safe initialization
        return instance;           // Only one instance ever created
    }
    
    // Prevent all forms of copying
    Singleton(const Singleton&) = delete;
    Singleton(Singleton&&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    Singleton& operator=(Singleton&&) = delete;
};
```

**What these prevent:**
```cpp
// All of these will cause compilation errors:
// Singleton s1;                    // Error: private constructor
// Singleton s2(getInstance());     // Error: copy constructor deleted
// Singleton s3 = getInstance();    // Error: assignment operator deleted
// auto s4 = getInstance();         // OK: gets reference to same instance
```

üî∏ Intermediate-Level Questions
üß† What are the drawbacks of using Singleton?
Ans: **Major drawbacks of Singleton pattern:**

1. **Global State** - Creates hidden dependencies and makes code harder to understand
2. **Testing Difficulties** - Hard to mock, unit tests affect each other due to shared state
3. **Tight Coupling** - Classes become tightly coupled to the Singleton instance
4. **Scalability Issues** - Can become a bottleneck in multi-threaded applications
5. **Violation of Single Responsibility** - Class manages both its functionality AND its instantiation
6. **Hidden Dependencies** - Dependencies are not explicit in constructors/methods
7. **Thread Safety Complexity** - Requires careful synchronization in multi-threaded environments
8. **Memory Management** - In C++, managing destruction can be tricky
9. **Inheritance Problems** - Difficult to extend or subclass properly

üß† Is Singleton an anti-pattern? Why or why not?
Ans: **Singleton is often considered an anti-pattern** for several reasons:

**Why it's considered an anti-pattern:**
‚ùå **Violates Dependency Inversion** - Creates hard dependencies instead of using abstractions
‚ùå **Makes testing difficult** - Cannot easily substitute mock objects
‚ùå **Global state issues** - Introduces hidden global state that can cause unexpected behavior
‚ùå **Reduces flexibility** - Hard to change behavior or extend functionality
‚ùå **Poor separation of concerns** - Mixes business logic with object creation logic

**When it might be acceptable:**
‚úÖ **Logging systems** - Single point for all log messages
‚úÖ **Configuration managers** - Single source of truth for app settings
‚úÖ **Resource managers** - Managing shared expensive resources (database connections)
‚úÖ **Hardware interfaces** - When only one instance can access hardware

**Better alternatives:**
- **Dependency Injection** - Pass instances as dependencies
- **Factory Pattern** - Control creation without enforcing single instance
- **Static classes** - For stateless utility functions

üß† How do you make a Singleton thread-safe?
Ans: **Several approaches to make Singleton thread-safe:**

1. **Static Local Variable (C++11+) - RECOMMENDED:**
```cpp
class ThreadSafeSingleton {
private:
    ThreadSafeSingleton() {}
public:
    static ThreadSafeSingleton& getInstance() {
        static ThreadSafeSingleton instance; // Thread-safe since C++11
        return instance;
    }
};
```

2. **Double-Checked Locking:**
```cpp
class Singleton {
private:
    static Singleton* instance;
    static std::mutex mtx;
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {                    // First check
            std::lock_guard<std::mutex> lock(mtx);
            if (instance == nullptr) {                // Second check
                instance = new Singleton();
            }
        }
        return instance;
    }
};
```

3. **Eager Initialization (Thread-safe by default):**
```cpp
class EagerSingleton {
private:
    static EagerSingleton* instance;
public:
    static EagerSingleton* getInstance() { return instance; }
};
EagerSingleton* EagerSingleton::instance = new EagerSingleton();
```

4. **std::once_flag (C++11):**
```cpp
class Singleton {
private:
    static Singleton* instance;
    static std::once_flag flag;
public:
    static Singleton* getInstance() {
        std::call_once(flag, []() { instance = new Singleton(); });
        return instance;
    }
};
```

üß† What is lazy initialization in Singleton?
Ans: **Lazy initialization** creates the Singleton instance only when it's first requested, not when the program starts.

**Characteristics:**
- Instance is created **on-demand** (when `getInstance()` is first called)
- Saves memory if the Singleton is never used
- Can improve startup time by deferring expensive initialization

**C++ Example:**
```cpp
class LazySingleton {
private:
    LazySingleton() {
        // Expensive initialization here
        std::cout << "Expensive initialization..." << std::endl;
    }
    
public:
    static LazySingleton& getInstance() {
        static LazySingleton instance; // Created only on first call
        return instance;
    }
};

// Usage:
int main() {
    // Instance NOT created yet
    std::cout << "Program started" << std::endl;
    
    // NOW instance is created (first call)
    LazySingleton& s1 = LazySingleton::getInstance();
    
    // Instance already exists (subsequent calls)
    LazySingleton& s2 = LazySingleton::getInstance();
    return 0;
}
```

**Advantages:**
‚úÖ Memory efficient - no instance if never used
‚úÖ Faster startup time
‚úÖ Resources allocated only when needed

**Disadvantages:**
‚ùå Slight performance hit on first access
‚ùå Thread-safety concerns (need synchronization)
‚ùå Unpredictable initialization timing

üß† What is eager initialization? When would you use it?
Ans: **Eager initialization** creates the Singleton instance immediately when the class is loaded or the program starts, 
rather than waiting for the first call to getInstance(). The instance is created regardless of whether it's actually used.

**C++ Examples:**

1. **Static Member Eager Initialization:**
```cpp
class EagerSingleton {
private:
    static EagerSingleton* instance;
    EagerSingleton() {}
    
public:
    static EagerSingleton* getInstance() {
        return instance;  // Already created at program start
    }
};

// Instance created immediately at program startup
EagerSingleton* EagerSingleton::instance = new EagerSingleton();
```

2. **Static Local Variable (C++11) - Also Eager:**
```cpp
class EagerSingleton {
private:
    EagerSingleton() {}
    
public:
    static EagerSingleton& getInstance() {
        static EagerSingleton instance;  // Created on first call, but guaranteed
        return instance;
    }
};
```

**When to use Eager Initialization:**
‚úÖ **Small, lightweight objects** - Low memory/CPU cost
‚úÖ **Frequently used singletons** - Will definitely be used
‚úÖ **Simple initialization** - No complex dependencies
‚úÖ **Avoid lazy initialization complexity** - No need for thread-safety concerns
‚úÖ **Predictable startup time** - All initialization happens upfront

**Advantages:**
- Thread-safe by default (created before main())
- No performance overhead on first access
- Simpler implementation

**Disadvantages:**
- Wastes memory if instance is never used
- Increases program startup time
- May cause issues with initialization order dependencies

üß† How do you prevent cloning or serialization from breaking Singleton?
Ans: **C++ techniques to prevent breaking Singleton through cloning/serialization:**

**1. Delete Clone/Copy Operations:**
```cpp
class Singleton {
private:
    Singleton() {}
    
public:
    // Prevent copying and cloning
    Singleton(const Singleton&) = delete;              // Copy constructor
    Singleton& operator=(const Singleton&) = delete;   // Copy assignment
    Singleton(Singleton&&) = delete;                   // Move constructor
    Singleton& operator=(Singleton&&) = delete;        // Move assignment
    
    // Prevent cloning through virtual clone method
    virtual Singleton* clone() = delete;
    
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

**2. Serialization Prevention (C++ with Boost.Serialization):**
```cpp
#include <boost/serialization/access.hpp>

class Singleton {
private:
    friend class boost::serialization::access;
    
    // Make serialization private and throw exception
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        throw std::runtime_error("Singleton serialization not allowed!");
    }
    
    Singleton() {}
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

**3. Custom Stream Operators Prevention:**
```cpp
class Singleton {
private:
    Singleton() {}
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    // Prevent copying via streams
    friend std::ostream& operator<<(std::ostream&, const Singleton&) = delete;
    friend std::istream& operator>>(std::istream&, Singleton&) = delete;
    
    // Prevent all forms of copying
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    Singleton(Singleton&&) = delete;
    Singleton& operator=(Singleton&&) = delete;
};
```

üß† What is the CRTP Singleton pattern in C++? When would you use it?
Ans: **CRTP (Curiously Recurring Template Pattern) Singleton** provides a reusable singleton base class:

```cpp
template<typename Derived>
class Singleton {
protected:
    Singleton() {}
    ~Singleton() {}
    
public:
    static Derived& getInstance() {
        static Derived instance;
        return instance;
    }
    
    // Prevent copying
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    Singleton(Singleton&&) = delete;
    Singleton& operator=(Singleton&&) = delete;
};

class Logger : public Singleton<Logger> {
    friend class Singleton<Logger>;  // Allow base class access
    
private:
    Logger() {}  // Private constructor
    
public:
    void log(const std::string& msg) {
        std::cout << msg << std::endl;
    }
};

class ConfigManager : public Singleton<ConfigManager> {
    friend class Singleton<ConfigManager>;
    
private:
    std::map<std::string, std::string> config;
    ConfigManager() {}
    
public:
    void setConfig(const std::string& key, const std::string& value) {
        config[key] = value;
    }
    
    std::string getConfig(const std::string& key) {
        return config[key];
    }
};

// Usage:
Logger& logger = Logger::getInstance();
ConfigManager& config = ConfigManager::getInstance();
```

**Benefits of CRTP Singleton:**
‚úÖ **Type-safe** - Each derived class gets its own singleton instance
‚úÖ **Reusable** - Single base class for multiple singletons
‚úÖ **No virtual function overhead** - Compile-time polymorphism
‚úÖ **Automatic thread safety** - Uses static local variables
‚úÖ **Prevents inheritance issues** - Each class is its own singleton

**When to use CRTP Singleton:**
- When you need multiple different singleton classes
- Want to avoid code duplication
- Need compile-time type safety
- Performance is critical (no virtual calls)

üß† What is the Pimpl idiom with Singleton in C++?
Ans: **Pimpl (Pointer to Implementation) idiom** can be combined with Singleton for better encapsulation:

```cpp
// Singleton.h
class Singleton {
private:
    class Impl;  // Forward declaration
    std::unique_ptr<Impl> pImpl;
    
    Singleton();
    ~Singleton();
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    void doSomething();
    void setData(int value);
    int getData() const;
    
    // Prevent copying
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// Singleton.cpp
class Singleton::Impl {
public:
    int data = 0;
    std::vector<std::string> privateStuff;
    
    void doSomethingInternal() {
        // Complex implementation hidden from header
    }
};

Singleton::Singleton() : pImpl(std::make_unique<Impl>()) {}
Singleton::~Singleton() = default;

void Singleton::doSomething() {
    pImpl->doSomethingInternal();
}

void Singleton::setData(int value) {
    pImpl->data = value;
}

int Singleton::getData() const {
    return pImpl->data;
}
```

**Benefits:**
‚úÖ **Binary compatibility** - Implementation changes don't require recompilation
‚úÖ **Faster compilation** - Reduced header dependencies
‚úÖ **Information hiding** - Private members truly hidden
‚úÖ **Exception safety** - RAII with smart pointers

üß† How do you break a Singleton pattern in C++? (Interview Trap Question)
Ans: **Multiple ways to break Singleton in C++ (what interviewers test your knowledge on):**

**1. Multiple Inheritance Attack:**
```cpp
class Base {};

class Singleton : public Base {
private:
    Singleton() {}
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};

// Breaking via inheritance (if not prevented)
class DerivedSingleton : public Singleton {
public:
    DerivedSingleton() {}  // If this compiles, singleton is broken!
};

// Multiple instances possible:
// DerivedSingleton d1, d2;  // Two different instances!
```

**2. Friend Class Attack:**
```cpp
class Singleton {
private:
    Singleton() {}
    friend class SingletonBreaker;  // Dangerous friendship!
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};

class SingletonBreaker {
public:
    static Singleton createNewInstance() {
        return Singleton();  // Creates new instance!
    }
};
```

**3. Macro Injection Attack:**
```cpp
#define private public  // Evil macro
#include "Singleton.h"
#undef private

// Now private constructor is accessible:
// Singleton s1, s2;  // Multiple instances!
```

**4. Template Specialization Attack:**
```cpp
template<>
class Singleton<int> {  // Specialized version
public:
    Singleton() {}  // Public constructor!
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

**5. Multi-threading Race Condition:**
```cpp
// Non-thread-safe implementation
class BrokenSingleton {
private:
    static BrokenSingleton* instance;
    
public:
    static BrokenSingleton* getInstance() {
        if (instance == nullptr) {  // Race condition here!
            instance = new BrokenSingleton();
        }
        return instance;
    }
};
```

**6. Memory Corruption Attack:**
```cpp
// Using placement new to corrupt singleton
Singleton& s1 = Singleton::getInstance();
char buffer[sizeof(Singleton)];
Singleton* s2 = new(buffer) Singleton();  // If constructor not protected enough
```

**7. Dynamic Library Loading:**
```cpp
// Each shared library gets its own static variables
// libA.so and libB.so each have their own Singleton instance
// even if they use the same header file
```

**How to prevent these attacks:**
- Use `final` keyword to prevent inheritance
- Avoid friend classes or be very careful
- Use unnamed namespaces
- Proper thread-safe implementation
- Delete copy/move constructors and operators
- Use static local variables (C++11+) for thread safety

üß† What are the alternatives to Singleton pattern?
Ans: **Better alternatives to consider instead of Singleton:**

**1. Dependency Injection:**
```cpp
class Logger {
public:
    void log(const std::string& message) { /* implementation */ }
};

class Service {
private:
    Logger& logger;  // Injected dependency
    
public:
    Service(Logger& log) : logger(log) {}
    
    void doWork() {
        logger.log("Doing work...");
    }
};

// Usage:
Logger logger;
Service service(logger);  // Inject the dependency
```

**2. Factory Pattern:**
```cpp
class LoggerFactory {
public:
    static std::shared_ptr<Logger> createLogger() {
        static std::shared_ptr<Logger> logger = std::make_shared<Logger>();
        return logger;  // Returns same instance, but not enforced
    }
};
```

**3. Static Class (for stateless utilities):**
```cpp
class MathUtils {
public:
    static int add(int a, int b) { return a + b; }
    static double sqrt(double x) { return std::sqrt(x); }
    
private:
    MathUtils() = delete;  // Prevent instantiation
};
```

**4. Monostate Pattern:**
```cpp
class Monostate {
private:
    static int sharedData;  // All instances share this data
    
public:
    void setData(int value) { sharedData = value; }
    int getData() const { return sharedData; }
};

// Multiple objects, but shared state
Monostate obj1, obj2;
obj1.setData(42);
std::cout << obj2.getData();  // Prints 42
```

**5. Service Locator Pattern:**
```cpp
class ServiceLocator {
private:
    static std::map<std::string, std::shared_ptr<void>> services;
    
public:
    template<typename T>
    static void registerService(const std::string& name, std::shared_ptr<T> service) {
        services[name] = service;
    }
    
    template<typename T>
    static std::shared_ptr<T> getService(const std::string& name) {
        return std::static_pointer_cast<T>(services[name]);
    }
};
```

**When to use alternatives:**
- **Dependency Injection**: When you need testability and flexibility
- **Factory Pattern**: When you want controlled creation without global access
- **Static Class**: For pure utility functions without state
- **Monostate**: When you need multiple instances with shared state
- **Service Locator**: For decoupled service access in large applications

üî∫ Advanced-Level Questions
------------------------------
üß† Double-Checked Locking in Singleton ?
Ans: Double-checked locking is a design pattern used to reduce the overhead of acquiring a lock by
first testing the locking criterion (e.g., whether the instance is null) without actually acquiring the lock. 
Only if the check indicates that locking is needed does the actual lock get acquired. This can improve performance in scenarios
where the cost of locking is high.

#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mtx;

    Singleton() {}

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {               // First check (no locking)
            std::lock_guard<std::mutex> lock(mtx);
            if (instance == nullptr) {           // Second check (with locking)
                instance = new Singleton();
            }
        }
        return instance;
    }

    // Delete copy and assignment
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// Static member initialization
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

üß† Why Two Checks?
First check avoids locking when the instance is already created.
Second check ensures only one instance is created even if multiple threads pass the first check simultaneously.

üß†How does Singleton differ from a static class?
Ans: **Key differences between Singleton and Static Class:**

| Aspect | **Singleton** | **Static Class** |
|--------|---------------|------------------|
| **Instantiation** | Creates objects (instances) | No objects, only static members |
| **Memory allocation** | Dynamic allocation (heap/stack) | Static allocation (program memory) |
| **Inheritance** | Can inherit and be inherited | Cannot inherit from or be inherited |
| **Polymorphism** | Supports polymorphism/interfaces | No polymorphism support |
| **State management** | Can have instance variables | Only static variables |
| **Initialization timing** | Lazy or eager (controlled) | At program load time |
| **Lifetime** | Can be destroyed/recreated | Exists for entire program duration |

**Singleton Example:**
```cpp
class Singleton {
private:
    int instanceData;                    // Instance variable
    Singleton() : instanceData(0) {}
    
public:
    static Singleton& getInstance() {
        static Singleton instance;       // Creates actual object
        return instance;
    }
    
    void setData(int val) { instanceData = val; }
    int getData() const { return instanceData; }
    
    // Can implement interfaces
    virtual void doSomething() { /* implementation */ }
};

// Usage:
Singleton& s = Singleton::getInstance();  // Gets object reference
s.setData(42);
```

**Static Class Example:**
```cpp
class StaticUtility {
private:
    static int staticData;               // Static variable only
    StaticUtility() = delete;            // Prevent instantiation
    
public:
    static void setData(int val) { staticData = val; }
    static int getData() { return staticData; }
    static int calculate(int a, int b) { return a + b; }
    
    // Cannot have virtual functions
    // Cannot implement interfaces properly
};

int StaticUtility::staticData = 0;       // Static initialization

// Usage:
StaticUtility::setData(42);              // Direct static call, no object
int result = StaticUtility::calculate(5, 3);
```

**When to use which:**

**Use Singleton when:**
‚úÖ Need to implement interfaces/inheritance
‚úÖ Want to control object lifecycle
‚úÖ Need polymorphic behavior
‚úÖ Want lazy initialization
‚úÖ Need to pass the instance around as parameter

**Use Static Class when:**
‚úÖ Pure utility functions (no state)
‚úÖ Mathematical operations
‚úÖ Helper/utility methods
‚úÖ No need for inheritance/polymorphism
‚úÖ Want compile-time optimization

üß†How would you implement Singleton in a distributed system or across processes?
Ans: **Implementing Singleton across processes/distributed systems requires external coordination:**

**1. File-Based Locking (Same Machine):**
```cpp
#include <fstream>
#include <filesystem>

class ProcessSingleton {
private:
    static ProcessSingleton* instance;
    std::string lockFile;
    
    ProcessSingleton() : lockFile("/tmp/process_singleton.lock") {
        // Try to create lock file
        if (std::filesystem::exists(lockFile)) {
            throw std::runtime_error("Another instance is already running!");
        }
        
        // Create lock file
        std::ofstream lock(lockFile);
        lock << getpid() << std::endl;  // Write process ID
    }
    
    ~ProcessSingleton() {
        std::filesystem::remove(lockFile);  // Clean up lock file
    }
    
public:
    static ProcessSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new ProcessSingleton();
        }
        return instance;
    }
};
```

**2. Named Mutex/Semaphore (Cross-Process):**
```cpp
#ifdef _WIN32
#include <windows.h>

class CrossProcessSingleton {
private:
    static CrossProcessSingleton* instance;
    HANDLE mutex;
    
    CrossProcessSingleton() {
        // Create named mutex visible across processes
        mutex = CreateMutex(NULL, TRUE, L"Global\\MyAppSingleton");
        
        if (GetLastError() == ERROR_ALREADY_EXISTS) {
            CloseHandle(mutex);
            throw std::runtime_error("Another instance is running!");
        }
    }
    
    ~CrossProcessSingleton() {
        ReleaseMutex(mutex);
        CloseHandle(mutex);
    }
    
public:
    static CrossProcessSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new CrossProcessSingleton();
        }
        return instance;
    }
};
#endif
```

**3. Database-Based Coordination (Distributed System):**
```cpp
#include <chrono>
#include <thread>

class DistributedSingleton {
private:
    static DistributedSingleton* instance;
    std::string nodeId;
    int leaseTimeout;
    
    DistributedSingleton() : nodeId("node_" + std::to_string(rand())) {
        if (!acquireLeadershipLease()) {
            throw std::runtime_error("Failed to acquire leadership!");
        }
        
        // Start lease renewal thread
        std::thread([this]() { renewLease(); }).detach();
    }
    
    bool acquireLeadershipLease() {
        // Pseudocode: Try to insert record with current timestamp
        /*
        SQL: INSERT INTO singleton_leader (id, node_id, lease_expiry) 
             VALUES (1, ?, NOW() + INTERVAL 30 SECOND)
             ON CONFLICT DO NOTHING
        */
        return true; // Return true if successful
    }
    
    void renewLease() {
        while (true) {
            std::this_thread::sleep_for(std::chrono::seconds(10));
            // Update lease expiry time
            /*
            SQL: UPDATE singleton_leader 
                 SET lease_expiry = NOW() + INTERVAL 30 SECOND
                 WHERE node_id = ? AND id = 1
            */
        }
    }
    
public:
    static DistributedSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new DistributedSingleton();
        }
        return instance;
    }
};
```

**4. Redis-Based Distributed Lock:**
```cpp
#include <redis++/redis++.h>

class RedisDistributedSingleton {
private:
    static RedisDistributedSingleton* instance;
    sw::redis::Redis redis;
    std::string lockKey;
    std::string nodeId;
    
    RedisDistributedSingleton() 
        : redis("tcp://127.0.0.1:6379"), 
          lockKey("singleton:lock"), 
          nodeId("node_" + std::to_string(rand())) {
        
        if (!acquireDistributedLock()) {
            throw std::runtime_error("Failed to acquire distributed lock!");
        }
    }
    
    bool acquireDistributedLock() {
        auto result = redis.set(lockKey, nodeId, 
                               std::chrono::seconds(30),  // TTL
                               sw::redis::UpdateType::NOT_EXIST);
        return result.has_value();
    }
    
public:
    static RedisDistributedSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new RedisDistributedSingleton();
        }
        return instance;
    }
};
```

**5. Consul/etcd Service Discovery:**
```cpp
class ConsulSingleton {
private:
    static ConsulSingleton* instance;
    std::string serviceId;
    
    ConsulSingleton() : serviceId("singleton-service-" + generateUUID()) {
        if (!registerWithConsul()) {
            throw std::runtime_error("Failed to register as singleton leader!");
        }
    }
    
    bool registerWithConsul() {
        // Register service with Consul
        // Use health checks and TTL to ensure only one instance
        /*
        PUT /v1/agent/service/register
        {
          "ID": serviceId,
          "Name": "singleton-leader",
          "Check": {
            "TTL": "30s",
            "DeregisterCriticalServiceAfter": "60s"
          }
        }
        */
        return true;
    }
    
public:
    static ConsulSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new ConsulSingleton();
        }
        return instance;
    }
};
```

**Key Strategies for Distributed Singleton:**

1. **Leader Election** - Use consensus algorithms (Raft, PBFT)
2. **Distributed Locking** - Redis, Zookeeper, etcd
3. **Database Constraints** - Unique constraints with timestamps
4. **Service Discovery** - Consul, etcd with health checks
5. **Message Queues** - Exclusive consumers in RabbitMQ/Kafka

**Challenges:**
‚ùå **Network partitions** - Split-brain scenarios
‚ùå **Failure detection** - Distinguishing between slow and dead nodes
‚ùå **Clock synchronization** - Distributed system time issues
‚ùå **Performance overhead** - Network calls for coordination

üß†What are the memory management concerns with Singleton in C++?
Ans: 
1. Memory Leaks : If you use new Singleton() without a corresponding delete, the instance will never be destroyed, 
        causing a memory leak.
‚úÖ Solution: Use a smart pointer or rely on static local variable (C++11+):

2. Destruction Order
In C++, the order of destruction of static objects across translation units is undefined. If your Singleton depends 
on other static objects, it might access them after they've been destroyed, leading to undefined behavior.
‚úÖ Solution:
Use local static variables (as above).
Or avoid dependencies on other static objects.
3. Thread Safety
As discussed, using new with a raw pointer and no synchronization can lead to race conditions.
‚úÖ Solution:
Use std::mutex with double-checked locking.
Or use static local variable (C++11+), which is thread-safe.

üß†How would you implement Singleton in a dependency injection framework?
Ans: In a dependency injection framework, you can implement Singleton by registering the Singleton instance with the
container and ensuring that the same instance is returned for each request. This can be done using various lifetime
management options provided by the framework, such as "singleton" or "scoped" lifetimes.

üß†What are the differences between Singleton and Multiton patterns?
Ans: The Singleton pattern restricts the instantiation of a class to a single instance,
while the Multiton pattern allows for the controlled instantiation of multiple instances, each identified by a unique key.
In other words, a Singleton has one global instance, whereas a Multiton can have several instances, each with its own state.


üß†Can Singleton be used in multithreaded logging or configuration systems? What are the risks?
Ans: Yes, Singleton can be used in multithreaded logging or configuration systems to ensure a single point of access for
logging or configuration data. However, the risks include:
1. Race Conditions: Multiple threads may attempt to access or modify the Singleton instance simultaneously, leading to inconsistent or corrupted state.
2. Deadlocks: Improper locking mechanisms can lead to deadlocks, where two or more threads are waiting indefinitely for each other to release locks.
3. Performance Bottlenecks: If the Singleton instance is heavily accessed, it can become a performance bottleneck, slowing down the entire system.
4. Testing Challenges: Singleton can make unit testing difficult, as it introduces global state that can affect tests in unexpected ways.
To mitigate these risks, you can use thread-safe Singleton implementations, such as using static local variables (C++11+) or implementing proper locking mechanisms (e.g., double-checked locking) to ensure thread safety.
üß†How do you handle Singleton in unit tests?
Ans: Handling Singleton in unit tests can be challenging due to its global state. Here are some strategies:

**1. Dependency Injection Approach:**
```cpp
// Instead of direct Singleton access
class Service {
public:
    void doWork() {
        Logger::getInstance().log("Working...");  // Hard to test
    }
};

// Use dependency injection
class Service {
private:
    ILogger& logger;
public:
    Service(ILogger& log) : logger(log) {}
    void doWork() {
        logger.log("Working...");  // Easy to mock
    }
};
```

**2. Reset Method:**
```cpp
class Singleton {
private:
    static Singleton* instance;
    int data;
    
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // For testing only
    static void reset() {
        delete instance;
        instance = nullptr;
    }
    
    void setData(int val) { data = val; }
    int getData() const { return data; }
};

// In test
TEST(SingletonTest, TestBehavior) {
    Singleton::reset();  // Clean state
    auto* s = Singleton::getInstance();
    s->setData(42);
    EXPECT_EQ(42, s->getData());
    Singleton::reset();  // Clean up
}
```

**3. Testable Singleton with Interface:**
```cpp
class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void log(const std::string& msg) = 0;
};

class Logger : public ILogger {
public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }
    
    void log(const std::string& msg) override {
        std::cout << msg << std::endl;
    }
};

// Mock for testing
class MockLogger : public ILogger {
public:
    MOCK_METHOD(void, log, (const std::string&), (override));
};
```

**4. Singleton Wrapper for Testing:**
```cpp
template<typename T>
class SingletonWrapper {
private:
    static T* testInstance;
    
public:
    static T& getInstance() {
        if (testInstance) {
            return *testInstance;  // Return test instance
        }
        return T::getInstance();   // Return real instance
    }
    
    static void setTestInstance(T* instance) {
        testInstance = instance;
    }
    
    static void resetTestInstance() {
        testInstance = nullptr;
    }
};

template<typename T>
T* SingletonWrapper<T>::testInstance = nullptr;
```

**Best Practices for Testing:**
‚úÖ Avoid Singletons in new code - use dependency injection
‚úÖ If you must use Singleton, provide reset mechanisms
‚úÖ Use interfaces to enable mocking
‚úÖ Consider singleton wrappers for legacy code
‚úÖ Test in isolation - each test should have clean state

üß† What is the initialization order problem with Singletons?
Ans: **The Static Initialization Order Fiasco** - a serious problem when Singletons depend on each other:

**The Problem:**
```cpp
// File1.cpp
class DatabaseManager {
public:
    static DatabaseManager& getInstance() {
        static DatabaseManager instance;
        return instance;
    }
    
private:
    DatabaseManager() {
        // Uses Logger during construction
        Logger::getInstance().log("Database initialized");
    }
};

// File2.cpp  
class Logger {
public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }
    
private:
    Logger() {
        // Uses Config during construction  
        auto config = ConfigManager::getInstance();
    }
};

// File3.cpp
class ConfigManager {
public:
    static ConfigManager& getInstance() {
        static ConfigManager instance;
        return instance;
    }
    
private:
    ConfigManager() {
        // Might use Database during construction
        // Creates circular dependency!
    }
};
```

**The Issue:**
- Order of static initialization across translation units is **undefined**
- If `DatabaseManager` is initialized before `Logger`, program crashes
- Creates circular dependencies
- Hard to debug and reproduce

**Solutions:**

**1. Dependency Injection (Best):**
```cpp
class DatabaseManager {
private:
    ILogger& logger;
    
public:
    DatabaseManager(ILogger& log) : logger(log) {
        logger.log("Database initialized");
    }
};

// Explicit initialization order
int main() {
    Logger logger;
    DatabaseManager db(logger);
    // Clear, predictable order
}
```

**2. Lazy Initialization with Careful Ordering:**
```cpp
class Logger {
public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }
    
private:
    Logger() {
        // Don't depend on other singletons in constructor
    }
};

class DatabaseManager {
public:
    static DatabaseManager& getInstance() {
        static DatabaseManager instance;
        return instance;
    }
    
private:
    DatabaseManager() {
        // Initialize after construction
    }
    
public:
    void initialize() {
        Logger::getInstance().log("Database initialized");
    }
};

// Usage:
int main() {
    DatabaseManager::getInstance().initialize();  // Explicit order
}
```

**3. Initialization Manager:**
```cpp
class InitializationManager {
public:
    static void initializeAll() {
        // Explicit order
        Logger::getInstance();
        ConfigManager::getInstance();  
        DatabaseManager::getInstance();
    }
};
```

üß† How does virtual inheritance affect Singleton implementation?
Ans: **Virtual inheritance can complicate Singleton implementation when using inheritance:**

**Problem with Regular Inheritance:**
```cpp
class Base {
public:
    virtual ~Base() = default;
    virtual void doSomething() = 0;
};

class Singleton : public Base {
private:
    Singleton() {}
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    void doSomething() override {
        std::cout << "Singleton implementation" << std::endl;
    }
    
    // Problem: What if someone tries this?
    // Singleton(const Singleton&) = delete;  // Good
    // But what about derived classes?
};

class DerivedSingleton : public Singleton {
    // This breaks the Singleton pattern!
    // Can create multiple instances through derived class
};
```

**Solution 1: Make Singleton Final (C++11):**
```cpp
class Singleton final : public Base {  // Cannot be inherited
private:
    Singleton() {}
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    void doSomething() override {
        std::cout << "Final singleton" << std::endl;
    }
};
```

**Solution 2: CRTP (Curiously Recurring Template Pattern):**
```cpp
template<typename Derived>
class Singleton {
protected:
    Singleton() {}
    ~Singleton() {}
    
public:
    static Derived& getInstance() {
        static Derived instance;
        return instance;
    }
    
    // Prevent copying
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

class Logger : public Singleton<Logger> {
    friend class Singleton<Logger>;  // Allow base class access
    
private:
    Logger() {}  // Private constructor
    
public:
    void log(const std::string& msg) {
        std::cout << msg << std::endl;
    }
};

// Usage:
Logger& logger = Logger::getInstance();
```

**Solution 3: Virtual Inheritance with Careful Design:**
```cpp
class ISingleton {
public:
    virtual ~ISingleton() = default;
    
protected:
    ISingleton() {}
};

class Singleton : public virtual ISingleton {
private:
    static Singleton* instance;
    
protected:
    Singleton() {}
    
public:
    static Singleton& getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return *instance;
    }
    
    // Prevent copying at this level
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};
```

**Key Considerations:**
- **Prefer composition over inheritance** for Singletons
- Use `final` keyword to prevent inheritance
- CRTP provides type-safe singleton base class
- Virtual inheritance adds complexity - avoid if possible
- Consider if you really need inheritance with Singleton

üî∏ Expert-Level Interview Questions
----------------------------------

üß† How would you implement a Thread-Safe Singleton that's also exception-safe?
Ans: **Exception-safe thread-safe Singleton requires careful RAII and exception handling:**

```cpp
#include <mutex>
#include <memory>

class ExceptionSafeSingleton {
private:
    static std::unique_ptr<ExceptionSafeSingleton> instance;
    static std::mutex mutex;
    
    // Private constructor that might throw
    ExceptionSafeSingleton() {
        // Simulate expensive initialization that might throw
        if (rand() % 10 == 0) {  // 10% chance of failure
            throw std::runtime_error("Initialization failed");
        }
        data = 42;
    }
    
    int data;
    
public:
    static ExceptionSafeSingleton& getInstance() {
        std::call_once(flag, []() {
            try {
                // Use make_unique for exception safety
                instance = std::make_unique<ExceptionSafeSingleton>();
            } catch (...) {
                // Reset flag to allow retry
                flag = std::once_flag{};
                throw;  // Re-throw the exception
            }
        });
        
        if (!instance) {
            throw std::runtime_error("Singleton initialization failed");
        }
        
        return *instance;
    }
    
    int getData() const { return data; }
    
    // Prevent copying
    ExceptionSafeSingleton(const ExceptionSafeSingleton&) = delete;
    ExceptionSafeSingleton& operator=(const ExceptionSafeSingleton&) = delete;
    
private:
    static std::once_flag flag;
};

// Static member definitions
std::unique_ptr<ExceptionSafeSingleton> ExceptionSafeSingleton::instance;
std::mutex ExceptionSafeSingleton::mutex;
std::once_flag ExceptionSafeSingleton::flag;
```

**Key Exception Safety Features:**
‚úÖ **RAII with smart pointers** - Automatic cleanup
‚úÖ **std::call_once** - Thread-safe initialization
‚úÖ **Exception retry mechanism** - Can retry failed initialization
‚úÖ **Strong exception guarantee** - No partial state on failure
‚úÖ **Resource leak prevention** - Smart pointers handle cleanup

This covers the most important missing interview questions that could come up in senior-level positions!

## **üìã Summary of C++ Singleton Interview Questions:**

1. **üß† How to prevent cloning/serialization** - Critical security question
2. **üß† CRTP Singleton pattern** - Advanced template-based approach  
3. **üß† Pimpl idiom with Singleton** - Encapsulation technique
4. **üß† How to break Singleton in C++** - Defensive programming knowledge
5. **üß† Alternatives to Singleton** - Design principle understanding
6. **üß† Unit testing strategies** - Practical development skills
7. **üß† Initialization order problems** - Advanced C++ knowledge
8. **üß† Virtual inheritance complications** - Expert-level understanding
9. **üß† Exception-safe implementation** - Production-ready code

Your C++ Singleton knowledge is now comprehensive for any level of interview! üöÄ
==================================================================================================

üéØ Your File Now Contains Only C++ Content:
üìö Basic Level:
C++ implementation examples
Modern C++11+ features
Static local variables approach
üîß Intermediate Level:
Thread safety with std::mutex
Double-checked locking
std::once_flag usage
‚ö° Advanced Level:
CRTP pattern implementation
Pimpl idiom combination
Virtual inheritance issues
Exception safety with smart pointers
üöÄ Expert Level:
C++ specific attack vectors
Template-based solutions
Memory management concerns
Compilation and linking issues